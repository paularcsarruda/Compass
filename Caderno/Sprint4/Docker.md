<svg version="1.1" id="Camada_1" xmlns="http://www.w3.org/2000/svg" x="0" y="0" viewBox="0 0 2500 635.6" style="enable-background:new 0 0 2500 635.6" xml:space="preserve"><path class="st0" d="M1180.7 401.9c.1-10.6-2.1-21.1-6.2-30.8-4-9.4-9.8-18-17-25.4-7.3-7.3-15.9-13.2-25.4-17.3-20-8.5-42.5-8.5-62.5 0-19 8.2-34.2 23.4-42.2 42.5-8.3 19.7-8.3 41.9 0 61.7 8 19.1 23.1 34.3 42.2 42.5 20 8.5 42.5 8.5 62.5 0 9.5-4.1 18.1-9.9 25.4-17.3 7.2-7.3 13-15.9 17-25.4 4.1-9.6 6.2-20 6.2-30.5zm-79.9-127.3c29.1-.4 57.3 9.4 79.9 27.8V189.2c-.3-12.8 9.8-23.4 22.6-23.7h1.1c6.3-.2 12.5 2.2 17 6.7 4.6 4.4 7.1 10.6 6.9 17V402c.7 33.9-12.9 66.5-37.3 90-49.7 49.7-130.3 49.6-180-.1s-49.6-130.3.1-180c23.8-23.8 56.1-37.2 89.7-37.3zm408.6 127.3c.7 33.9-12.9 66.5-37.3 90-49.7 49-129.7 48.4-178.7-1.2-49-49.7-48.4-129.7 1.2-178.7 49.7-49 129.7-48.4 178.7 1.2 11.3 11.5 20.4 25 26.6 39.9 6.3 15.5 9.7 32 9.8 48.7h-.3zm-127.3-79.8c-10.8-.1-21.5 2.1-31.4 6.4-19 8.2-34.2 23.4-42.2 42.5-8.3 19.7-8.3 41.9 0 61.7 8 19.1 23.1 34.3 42.2 42.5 20 8.5 42.5 8.5 62.5 0 9.5-4.1 18.1-9.9 25.4-17.3 7.2-7.3 13-15.9 17-25.4 8.4-19.7 8.4-42 0-61.7-4-9.4-9.8-18-17-25.4-7.3-7.3-15.9-13.2-25.4-17.3-9.8-4.1-20.2-6.2-30.8-6.1h-.3zm348 135c12.8-.3 23.4 9.8 23.7 22.6v1.1c0 6.6-2.8 13-7.7 17.5-53.2 45.9-133.6 40-179.5-13.2s-40-133.6 13.2-179.5c47.8-41.2 118.5-41.2 166.3 0 5.3 4.5 8.3 11.1 8.2 18 .2 6.4-2.2 12.5-6.7 17s-10.6 6.9-17 6.8c-5.6 0-11.1-1.9-15.4-5.5-7.2-6.2-15.4-11.2-24.3-14.8-8.9-3.4-18.3-5.1-27.8-5-10.6 0-21.1 2.1-30.8 6.2-9.5 4-18.1 9.8-25.4 17-7.3 7.3-13.2 15.9-17.2 25.4a81.05 81.05 0 0 0 0 62.3c4 9.5 9.9 18.1 17.2 25.4 7.3 7.2 16 13 25.4 17 9.7 4.2 20.2 6.3 30.8 6.2 9.5.1 18.9-1.5 27.8-4.9 8.8-3.5 17-8.4 24.1-14.6 4.5-3.3 9.9-5.1 15.4-5h-.3zm51.2 48.2v-316c-.1-13.1 10.4-23.8 23.4-23.9h.5c6.3-.1 12.3 2.4 16.7 6.9 4.5 4.5 7.1 10.6 6.9 17v177.3l135.9-88.4c3.8-2.4 8.2-3.7 12.7-3.6 3.2 0 6.4.6 9.3 1.8 2.9 1.1 5.5 2.9 7.7 5.1 2.1 2.3 3.9 4.9 5.1 7.7 1.3 2.9 1.9 6 1.9 9.1.5 7.5-2.9 14.6-9.1 18.9l-95.2 61.7 97.7 110c4.3 4.5 6.6 10.4 6.6 16.6 0 3.1-.6 6.2-1.9 9.1-1.2 2.8-3 5.5-5.1 7.7-2.2 2.2-4.8 3.9-7.7 5.1-3 1.2-6.1 1.9-9.3 1.8-5.9.2-11.6-2.1-15.9-6.2l-105-117.9-27.7 18.2v82c.1 6.3-2.4 12.4-6.9 16.8-4.4 4.6-10.4 7.1-16.7 7-6.4.1-12.5-2.4-17-7-4.4-4.4-6.8-10.5-6.7-16.7h-.2zm449.5-127.1a76.9 76.9 0 0 0-11.5-23.1c-10-13.7-24-23.9-40-29.2-8.1-2.7-16.6-4.1-25.1-4.1-8.6 0-17.1 1.4-25.2 4.1-8 2.7-15.6 6.5-22.5 11.5-6.8 4.9-12.8 10.9-17.7 17.7-5 7-8.8 14.8-11.1 23.1h153.1zm-10.2 79.4c12.8-.4 23.5 9.6 23.9 22.3v1.3c.1 6.4-2.3 12.5-6.8 17-53.2 46-133.5 40.1-179.5-13-46-53.2-40.1-133.5 13-179.5 23.1-20 52.7-31 83.3-31 51.4.3 97.7 31.1 117.9 78.3 6.3 15.5 9.5 32.2 9.3 48.9.2 6.4-2.3 12.5-6.9 17-4.5 4.5-10.6 6.9-17 6.7H2078c2.5 8.3 6.3 16.1 11.3 23.1 4.9 6.8 10.9 12.8 17.7 17.7 6.8 5 14.3 8.8 22.3 11.5 8.2 2.7 16.7 4.1 25.4 4.1 9.4.1 18.7-1.4 27.5-4.5 8.5-3.1 16.3-7.7 23.1-13.6 4.3-3.9 9.9-6.1 15.6-6.3h-.3zm134.5-159.4v4.5c11.1-8.9 23.7-16 37.1-20.9 13.7-4.9 28.2-7.4 42.7-7.2 7.2 0 14.4.5 21.5 1.4 7.2.8 14.3 2.4 21.1 4.9 6 2 11.4 5.3 16 9.6 4.3 4.2 6.6 9.9 6.4 15.9 0 3.2-.6 6.4-1.9 9.3-1.2 2.8-3 5.5-5.1 7.7-2.2 2.2-4.8 3.9-7.7 5.1-3 1.2-6.1 1.9-9.3 1.8-3.5-.1-6.9-1-10-2.5-9.8-3.8-20.3-5.8-30.8-5.7-10.6 0-21.1 2.1-30.8 6.2a79.96 79.96 0 0 0-42.4 42.4c-4.2 9.7-6.3 20.2-6.2 30.8v103.6c0 13.1-10.6 23.7-23.7 23.7-6.4.1-12.5-2.4-17-6.9-4.5-4.4-7-10.4-6.9-16.7v-207c-.1-6.3 2.4-12.3 6.9-16.7 4.5-4.5 10.6-7.1 17-6.9 13.1 0 23.7 10.6 23.7 23.7h-.6zM862.6 242.6c-19.8-13.8-65.3-18.9-100.8-12-4.2-34.4-23.1-64.5-56.2-91.2l-19-13.8-13.3 19.8c-17.2 29-25 62.7-22.3 96.4 1.4 18.6 7.4 36.7 17.3 52.5-20.6 10.7-43.7 16-66.9 15.4H3.9l-1.6 6.9C-3.5 350.9-3.5 458.4 64 541c51.3 62.8 127.3 94.6 227.2 94.6 216.5 0 376.9-104.1 452-292.5 29.8.8 93.3 0 125.6-64.5.8-1.7 2.5-5.2 8.2-18l3.3-6.9-18.2-11.2.5.1zM481.6 0h-90.9v86h90.9V0zm0 103.2h-90.9v86h90.9v-86zm-107.5 0h-90.9v86h90.9v-86zm-107.5 0h-90.8v86h90.9l-.1-86zM159.2 206.4H68.4v86h90.9l-.1-86zm107.4 0h-90.8v86h90.9l-.1-86zm107.5 0h-90.9v86h90.9v-86zm107.5 0h-90.9v86h90.9v-86zm107.4 0h-90.9v86H589v-86z"/></svg>
![docker](https://github.com/paularcsarruda/Compass/assets/122739036/8bbe98a1-8bac-4b80-9c46-cb016402a9f1)

## O que é Docker?

O Docker é uma plataforma de software livre que permite aos desenvolvedores desenvolver, implementar, executar, atualizar e gerenciar componentes de *contêineres* executáveis e padronizados que combinam o código-fonte de aplicativos com as bibliotecas e estruturas do sistema operacional (S.O.) necessárias para executar o código em qualquer ambiente.

## Por quê utilizar o Docker?

- O **Docker proporciona mais velocidade na configuração do ambiente** de um desenvolvedor.
- Pouco tempo gasto em manutenção, containers são executados como configurados
- Performance para executar aplicação, mais performático que uma vm
- NOs livra da **Matrix from Hell**

## Primeiro Teste - Containers

`docker run` docker/whalesay `cowsay` Hello_world

# Containers

### **Como os contêineres funcionam**

A **tecnologia de contêineres oferece todas as funcionalidades e os benefícios das máquinas virtuais, incluindo isolamento de aplicativos, ajuste de escala com custo reduzido e descartabilidade**, além de outras vantagens importantes:

- **Mais leve:** ao contrário das VMs, os contêineres não hospedam a carga útil de uma instância inteira de sistemas operacionais e hypervisors. Estes incluem apenas os processos e as dependências do sistema operacional que são necessários para executar o código. Seu tamanho é medido em megabytes (em vez de em gigabytes, como em algumas VMs), fazem melhor uso da capacidade de hardware e oferecem tempos de inicialização mais rápidos.
- **Melhor produtividade do desenvolvedor:** aplicativos em contêineres podem ser gravados uma vez e executados em qualquer lugar. E, comparados às VMs, a implementação, o provisionamento e a reinicialização dos contêineres ocorre de maneira mais simples e rápida. Isso os torna ideais para uso em pipelines de integração contínua e entrega contínua e mais adequados para equipes de desenvolvimento que adotam práticas de DEvOps e Agile.
- **Maior eficiência de recursos:** os contêineres permitem aos desenvolvedores executar várias vezes no mesmo hardware o mesmo número de cópias de um aplicativo que as VMs. Isso pode reduzir seus gastos com a cloud.

## Definindo o nome do Container

- podemos definir o nome usando a flag `--name`
- se não colocarmos o nome, receberemos um nome aleatório
- a flag é inserida junto do comando run: `docker run -- name <NAME>`

# Comandos Básicos

`docker version` → verifica a versão

`docker --help`

`docker run` → roda Containers, sempre inicia um novo Container

**`docker run -it ubuntu` -> roda o terminal do Ubuntu**

`exit` → para a execução

`docker ps` ou `docker container ls` → exibe quais **Containers** estão sendo executados no momento;

`flag -a` -> temos também todos os **Containers** já executados na máquina e.g.: `docker ps -a`

`Flag -it` → rodar **Container** e deixá-lo executando no terminal

`docker stop <id ou nome>` → parar o Container

`docker start <id>` → inicia o Container

## Verificando Logs

- podemos verificar o que aconteceu em um Container, utilizando: `docker logs <id>`
- assim, as últimas ações realizadas no Container serão exibidas no terminal

## Removendo Containers

- podemos remover um Container da máquina, utilizando: `docker -rm <id>`
- se o Container ainda estiver rodando podemos utilizar a `flag -f`(force)

# Imagens

## O que são Imagens?

Uma imagem do Docker, ou imagem de contêiner, é um arquivo executável independente usado para criar um contêiner. Essa imagem de contêiner contém todas as bibliotecas, dependências e arquivos de que o contêiner precisa para ser executado. Uma imagem do Docker é compartilhável e portátil, então você pode implantar a mesma imagem em vários locais ao mesmo tempo, da mesma forma que um arquivo binário de software.

## Como escolher uma boa Imagem

- podemos fazer o download das imagens em https://hub.docker.com

## Criando uma Imagem

- para criar uma imagem vamos precisar de um arquivo Dockerfile em uma pasta que ficará o projeto
- esse arquivo vai precisar de algumas instruções para ser executado
- **FROM:** imagem base
- **WORKDIR:** diretório da aplicação
- **EXPOSE:** porta da aplicação
- **COPY:** quais arquivos precisam ser copiados

# Docker Swarn

# YAML

O YAML é uma linguagem legível de serialização de dados muito usada na escrita de arquivos de configuração. Dependendo, a sigla YAML pode significar em inglês yet another markup language (mais uma linguagem de marcação) ou YAML ain’t markup language (YAML não é linguagem de marcação) [acrônimo recorrente]. Ambos destacam que o YAML é voltado para os dados, e não documentos.

```
# Para comentários basta usar o caractere (#).
# Yaml não permite
# multiplas linhas em comentário.
```

Podemos ter **strings, null, integers, floats e booleanos.** As strings podem ser com ou sem aspas duplas (“ ”) ou únicas (‘ ’), geralmente use elas quando se tem caracteres especiais.

```
#Doc 1
---# Start
tipo: "Teste"# ou 'Teste' ou teste
teste: true
numero: 1
nulo: null
...# End
```

Para data é seguido o padrão ISO 8601. (yyyy-mm- ddThh:mm:ss.ffffff)

Note que é importante indentar o código com espaços.

```
#Doc 2
---
pessoa:
nome: &nome Fulano
sobrenome: Cicrano
idade: 45
data_nascimento: 1974-05-13 09:25:55
"estado civil": null
masculino: true

hobbies:
-'andar de bicicleta'
- patinar
-nadar
```

As listas podem conter *colchetes* ([]), e caso precisar pode usar uma estrutura parecida com dicionário em python ({}) com *chaves* para o item *‘chave:valor’* os membros da lista são indicados por (-) *hífen.*

```
nadar: ["Praia", "Piscina", "Lago"]
amigos:
- nome: "João"
idade: 25
- {nome: "Eduardo",idade: 24}                           -
-
nome: "Frederico"
    idade: 26
```

Caso queira que o YAML leia mais de uma linha em uma chave pode ser usado o caractere *maior* (>), no retorno ele junta tudo e retorna uma linha somente. Quando se usa o *pipe* (|) ele retorna com varias linhas de acordo com a estrutura que foi criada. [Aqui](https://rollout.io/blog/yaml-tutorial-everything-you-need-get-started/) tem uns exemplos bons.

```
descricao:>
  Aqui tem algumas caracteristicas do fulano,
  ele possui 45 anos e tem alguns amigos.
  Ele adora esportes.

assinatura:|
  Fulano
  Cicrano Org
  email - cicrano.fulano@gmail.comid:*nome
...
```

# Kubernetes ‘K8S’

## O que são Kubernetes?

Originates from Ancient Greek, meaning 'helmsman' or 'pilot’

- uma **ferramenta de orquestração de containers**
- permite a criação de múltiplos containers em diferentes máquinas (nodes)
- escalando projetos, **formando um cluster**
- gerencia serviços, garantindo que as aplicações sejam executadas sempre da mesma forma
- criada pelo **google**

## Conceitos Fundamentais

- **Control Plane:** onde é gerenciado o controle dos processos dos **Nodes**
- **Nodes:** máquinas que são gerenciadas pelo control plane
- **Deployment:** a execução de uma imagem/projeto de um Pod
- **Pod:** um ou mais containers que estão em um Node
- **Services:** serviços que expõe os Pods ao mundo externo
- **Kubectl:** cliente de linha de comando para Kubernetes

## Dependências Necessárias

- o Kubernetes pode ser executado de uma maneira simples em nossa máquina
- vamos precisar do client Kubectl, que é uma maneira de executar o Kubernetes
- e também o Minikube, **uma espécie de simulador** de Kubernetes, para não precisarmos de vários computadores/servidores

## Iniciando o Minikube

- para inicializar o Minikube vao=mos utilizar o comando `minikube start --drive=<DRIVE>`
- onde o driver vai depender de como foi a sua instalação das dependÊncias e por qualquer um deles atingiremos os mesmos resultados
- pode ser utilizado o docker ou VM's
- podemos testar o minikube com: `minikube status`

## Comandos

- `minikube start --driver=docker` → inicializa o minikube
- `minikube status`
- `minikube stop`
- para **iniciar novamente repete o comando start**

# Acessando a Dashboard do Kubernetes

- o minikube nos disponibiliza uma dashboard
- onde podemos ver todo o detalhamento do nosso projeto: serviços, pods, etc.
- comando: `minikube dashboard`
- ou para apenas obter a URL: `minikube dashboard --url`

## Deployment teoria

- o **Deployment** é uma parte fundamental do **Kubernetes**
- como ele criamos nosso serviço que vai rodar nos **pods**
- definimos uma **imagem e um nome**, para posteriormente ser replicado entre os servidores
- a partir da criação dos Deployment teremos containers rodando
- vamos precisar de uma imagem no Hub do Docker, para gerar um Deployment

## Criar Deployment

- para rodar o projeto no Kubernetes é necessário um Deployment, que é onde rodamos os containers das aplicações no Pods
- o comando é: `kubectl create deployment <NOME> --image=<IMAGEM>`
- desta forma, o projeto de Flask estará sendo orquestrado pelo Kubernetes

## Checando Deployments

- para verificar o Deployment: `kubectl get deployments`
- para verificar detalhes: `kubectl describe deployments`
- desta forma conseguimos saber se o projeto está de fato rodando e também o que está rodando neles

## Checando Pods

- os Pods também são componentes muito importantes, é o local onde os Containers são executados
- para verificar os Pods utilizamos: `kubectl get pods`
- para verificar detalhes: `kubectl describe pods`
- desta forma recebemos o status dos Pods que estão ligados e também informações importantes sobre eles

## Configurações do Kubernetes

- podemos verificar como o Kubernetes está configurado utilizando:
- `kubectl config view`
- desta forma receberemos informações importantes baseadas no Minikube, que é por onde o Kubernetes está sendo executado

## Service Teoria

- as apps de Kubernetes não tem conexão com o mundo externo
- por isso é necessário a criação de um Service, que é o que possibilita expor os Pods
- o Service é uma entidade separada dos Pods, que expões eles a uma rede

## Criando um Service

- para criar um serviço e expor nossos Pods: `kubectl expose deployment <NOME> --type=<TIPO> --port=<PORT>`
- colocaremos o nome do Deployment já criado
- o tipo de Service, há vários para utilizarmos, porém o LoadBalancer é o mais comum, onde todos os Pods são expostos
- e uma porta para o serviço ser consumido

## Verificando nossos Services

- podemos obter detalhes dos Services já criados, utilizando: `kubectl get services`
- e obter informações de um Service específico com: `kubectl descrive services/<NOME>`

## Replicando a Aplicação

- podemos utilizar outros Pods e replicar nossa aplicação
- o comando é: `kubectl scale deployment/<NOME> --replicas=<NUMERO>`
- podemos agora verificar no Dashboard o aumento de Pods
- e também com o comando de: `kubectl get pods`

## Verificando o número de Réplicas

- `kubectl get rs`
- desta maneira temos os status das réplicas dos projetos

## Diminuindo a Escala

- podemos facilmente diminuir o número de Pods
- esta técnica é chamada de scale down
- `kubectl scale deployment/<NOME> --replicas=<NUMERO_MENOR>`

## Atualização da Imagem

- para atualizar a imagem vamos precisar do nome do Container, isso é dado na Dashboard dentro do Pod
- e também a nova imagem deve ser uma outra versão da atual, precisamos subir uma nova tag no Hub
- depois utilizar o comando: `kubectl set image deployment/<NOME> <NOME_CONTAINER>=<NOVA_IMAGEM>`

## Desfazer alteração

- para desfazer uma alteração utilizamos uma ação conhecida como rollback
- o comando para verificar a alteração é: `kubectl rollout status deployment/<NOME>`
- com ele e com o `kubectl get pods`, podemos identificar problemas
- para voltar a alteração utilizamos: `kubectl rollout undo deployment/<NOME>`

## Deletar um Service

- para deletar um Service, utilizamos o comando: `kubectl delete service <NOME>`

## Deletando um deployment

- para deletar um deployment, utilizamos o comando: `kubectl delete deployment <NOME>`

## Modo Declarativo

- o modo declarativo é guiado por um arquivo, semelhante ao Docker Compose
- dessa forma tornamos nossas configurações mais simples e centralizamos tudo em um comando
- também escrevemos em YAML o arquivo de Kubernetes

## Chaves mais utilizadas

- **apiVersion:** versão utilizada da ferramenta
- **kind:** tipo de arquivo (Deployment, Service)
- **metadata:** descrever algum objeto, inserindo chaves como name
- **replicas:** número de réplicas de Nodes/Pods
- **containers:** definir as especificações de containers como: nome e imagem

## Criando o arquivo

- para transformar o projeto em declarativo, vamos criar um arquivo para realizar o Deployment
- Desta maneira vamos aprender a criar os arquivos declarativos e utilizar as chaves e valores

## Executando arquivo de Deployment

- o comando para executar o arquivo é: `kubectl apply -f<ARQUIVO>`
- desta maneira o Deployment será criado conforme configurado no arquivo YAML

## Parando o Deployment

- para parar de executar o deployment baseado em arquivo, o declarativo, utilizamos também o delete
- o comando é `kubectl delete -f<ARQUIVO>`
- desta maneira, teremos os Pods sendo excluídos e o serviço finalizado

## Criando o Serviço

- para criar o Serviço declarativo temos que criar um arquivo para realizar o Service(kind)

## Executando o Serviço

- o comando é `kubectl apply -f <ARQUIVO>`
- Obs.: precisamos gerar o IP de acesso com `minikube service <NOME>`

## Parando o Serviço

- o comando é o `kubectl delete -f <ARQUIVO>`
- desta maneira o serviço não estará mais disponível, e perderemos acesso ao projeto

## Atualizando o Projeto no Declarativo

- primeiro temos que criar uma nova versão da imagem
- e fazer o `push` para o Hub
- depois é só alterar no arquivo de Deployment a `tag`
- e reaplicar o comando de `apply`

## Unindo Arquivos do Projeto

- vamos precisar unior o deployment e o service em um único arquivo
- a separação de objetos para o YAML é com: `---`
- desta forma, cada um deles será executado
- uma boa prática é colocar o service antes do deployment
